#! /usr/bin/env python

import roslib; roslib.load_manifest('hekateros_control')
import rospy

# Brings in the SimpleActionClient
import actionlib

# Brings in the messages used by the fibonacci action, including the
# goal message and the result message.
import control_msgs.msg
import trajectory_msgs.msg

def fibonacci_client():
    # Creates the SimpleActionClient, passing the type of the action
    client = actionlib.SimpleActionClient( 
            'hekateros_control/follow_joint_traj_as', 
            control_msgs.msg.FollowJointTrajectoryAction)

    # Waits until the action server has started up and started
    # listening for goals.
    client.wait_for_server()

    # Creates a goal to send to the action server.
    goal = control_msgs.msg.FollowJointTrajectoryGoal()
    joint_traj = trajectory_msgs.msg.JointTrajectory()

    jtp = trajectory_msgs.msg.JointTrajectoryPoint()
    jtp.positions.insert(0,0.4); jtp.velocities.insert(0,10)
    jtp.positions.insert(1,3.2); jtp.velocities.insert(1, 100)
    jtp.positions.insert(2,1.5); jtp.velocities.insert(2, 100)

    jtp2 = trajectory_msgs.msg.JointTrajectoryPoint()
    jtp2.positions.insert(0,0.9); jtp2.velocities.insert(0,10)
    jtp2.positions.insert(1,-3.2); jtp2.velocities.insert(1, 100)
    jtp2.positions.insert(2,-1.5); jtp2.velocities.insert(2, 100)
    
    jtp3 = trajectory_msgs.msg.JointTrajectoryPoint()
    jtp3.positions.insert(0,0.0); jtp3.velocities.insert(0,10)
    jtp3.positions.insert(1,0.0); jtp3.velocities.insert(1, 100)
    jtp3.positions.insert(2,0.0); jtp3.velocities.insert(2, 100)

    jtp4 = trajectory_msgs.msg.JointTrajectoryPoint()
    jtp4.positions.insert(0,0.4); jtp4.velocities.insert(0,5)
    jtp4.positions.insert(1,0.0); jtp4.velocities.insert(1, 100)
    jtp4.positions.insert(2,0.0); jtp4.velocities.insert(2, 100)

    jtp5 = trajectory_msgs.msg.JointTrajectoryPoint()
    jtp5.positions.insert(0,0.0); jtp5.velocities.insert(0,5)
    jtp5.positions.insert(1,0.0); jtp5.velocities.insert(1, 100)
    jtp5.positions.insert(2,0.0); jtp5.velocities.insert(2, 100)

    joint_traj.joint_names.insert(0,'grip')
    joint_traj.joint_names.insert(1,'wrist_rot')
    joint_traj.joint_names.insert(2,'wrist_pitch')
    joint_traj.points.insert(0,jtp)
    joint_traj.points.insert(1,jtp2)
    joint_traj.points.insert(2,jtp3)
    joint_traj.points.insert(3,jtp4)
    joint_traj.points.insert(4,jtp5)

    goal.trajectory = joint_traj
    print goal

    # Sends the goal to the action server.
    client.send_goal(goal)

    # Waits for the server to finish performing the action.
    client.wait_for_result()

    # Prints out the result of executing the action
    print "e"
    return client.get_result()  # A FibonacciResult

if __name__ == '__main__':
    try:
        # Initializes a rospy node so that the SimpleActionClient can
        # publish and subscribe over ROS.
        rospy.init_node('joint_traj_client')
        result = fibonacci_client()
        #print "Result:", ', '.join([str(n) for n in result.sequence])
    except rospy.ROSInterruptException:
        print "program interrupted before completion"
